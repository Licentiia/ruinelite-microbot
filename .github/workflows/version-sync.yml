name: Version sync

on:
  workflow_dispatch:
  schedule:
    - cron: "0 6 * * *" # daily at 06:00 UTC

jobs:
  update-sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Set API base and headers
        run: |
          echo "GH_API=https://api.github.com" >> $GITHUB_ENV
          echo "GH_HEADERS=-H 'Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' -H 'Accept: application/vnd.github+json' -H 'X-GitHub-Api-Version: 2022-11-28'" >> $GITHUB_ENV
          echo "UPSTREAM=chsami/Microbot" >> $GITHUB_ENV
          echo "OWNER_REPO=${{ github.repository }}" >> $GITHUB_ENV

      # --- Microbot (upstream): latest released numeric version (ignore 'nightly') ---
      - name: Get Microbot latest release (numeric tag, ignore 'nightly')
        id: microbot_release
        run: |
          set -e
          # Use the releases list (not /latest) and skip 'nightly'
          eval curl -fsSL $GH_HEADERS "$GH_API/repos/$UPSTREAM/releases?per_page=100" > /tmp/microbot_releases.json

          # First non-'nightly' tag
          MICROBOT_RELEASE_TAG=$(jq -r '[.[] | .tag_name | select(. != "nightly")] | .[0]' /tmp/microbot_releases.json)

          # Extract >=3-part numeric version (supports 1.9.8 and 1.9.8.1)
          MICROBOT_VERSION=$(echo "$MICROBOT_RELEASE_TAG" | grep -Eo '[0-9]+(\.[0-9]+){2,}' || true)

          # Fallback: look into asset names if tag name didn’t contain a numeric version
          if [ -z "$MICROBOT_VERSION" ] || [ "$MICROBOT_VERSION" = "null" ]; then
            MICROBOT_VERSION=$(jq -r '.[]?.assets[]?.name' /tmp/microbot_releases.json \
              | grep -Eo '[0-9]+(\.[0-9]+){2,}' \
              | sort -V | tail -n1 || true)
          fi

          # Last resort: just use the tag string
          if [ -z "$MICROBOT_VERSION" ] || [ "$MICROBOT_VERSION" = "null" ]; then
            MICROBOT_VERSION="$MICROBOT_RELEASE_TAG"
          fi

          echo "MICROBOT_RELEASE_TAG=$MICROBOT_RELEASE_TAG" >> $GITHUB_ENV
          echo "MICROBOT_VERSION=$MICROBOT_VERSION" >> $GITHUB_ENV

      - name: Resolve Microbot release commit SHA
        id: microbot_release_sha
        run: |
          set -e
          eval curl -fsSL $GH_HEADERS "$GH_API/repos/$UPSTREAM/git/refs/tags/${MICROBOT_RELEASE_TAG}" > /tmp/tagref.json
          TAG_OBJ_SHA=$(jq -r .object.sha /tmp/tagref.json)
          TAG_OBJ_TYPE=$(jq -r .object.type /tmp/tagref.json)
          if [ "$TAG_OBJ_TYPE" = "commit" ]; then
            RELEASE_COMMIT_SHA="$TAG_OBJ_SHA"
          else
            eval curl -fsSL $GH_HEADERS "$GH_API/repos/$UPSTREAM/git/tags/${TAG_OBJ_SHA}" > /tmp/tagobj.json
            RELEASE_COMMIT_SHA=$(jq -r .object.sha /tmp/tagobj.json)
          fi
          echo "RELEASE_COMMIT_SHA=$RELEASE_COMMIT_SHA" >> $GITHUB_ENV

      # --- Upstream & our dev heads (for Dev Sync) ---
      - name: Get Microbot main & development heads
        id: microbot_heads
        run: |
          set -e
          MAIN_SHA=$(eval curl -fsSL $GH_HEADERS "$GH_API/repos/$UPSTREAM/commits/main" | jq -r .sha)
          if DEV_JSON=$(eval curl -fsSL $GH_HEADERS "$GH_API/repos/$UPSTREAM/commits/development"); then
            DEV_SHA=$(echo "$DEV_JSON" | jq -r .sha)
          else
            DEV_SHA="$RELEASE_COMMIT_SHA"
          fi
          echo "MAIN_SHA=$MAIN_SHA" >> $GITHUB_ENV
          echo "DEV_SHA=$DEV_SHA" >> $GITHUB_ENV

      - name: Dev Sync - upstream/development vs our development (git-based)
        id: devsync
        run: |
          set -e
          # Ensure we have full history for accurate counts
          git fetch --prune --unshallow origin || true

          # Make sure our local refs exist
          git fetch origin +refs/heads/development:refs/remotes/origin/development || true

          # Add/fetch upstream (public) dev
          git remote add upstream https://github.com/${UPSTREAM}.git || true
          git fetch upstream +refs/heads/development:refs/remotes/upstream/development || true

          # If upstream/dev doesn't exist, treat as in sync
          if ! git rev-parse --verify refs/remotes/upstream/development >/dev/null 2>&1; then
            echo "DEV_AHEAD=0"  >> $GITHUB_ENV
            echo "DEV_BEHIND=0" >> $GITHUB_ENV
            echo "DEV_STATUS_TEXT=Synced" >> $GITHUB_ENV
            echo "DEV_STATUS_BADGE=https://img.shields.io/badge/Microbot%20Dev-Synced-brightgreen?style=flat" >> $GITHUB_ENV
            exit 0
          fi

          # If our dev is missing, we're behind by all upstream commits
          if ! git rev-parse --verify refs/remotes/origin/development >/dev/null 2>&1; then
            BEHIND=$(git rev-list --count refs/remotes/upstream/development)
            echo "DEV_AHEAD=0"        >> $GITHUB_ENV
            echo "DEV_BEHIND=$BEHIND" >> $GITHUB_ENV
            echo "DEV_STATUS_TEXT=Nightly Available" >> $GITHUB_ENV
            echo "DEV_STATUS_BADGE=https://img.shields.io/badge/Microbot%20Dev-Nightly%20Available-yellow?style=flat" >> $GITHUB_ENV
            exit 0
          fi

          # Count ahead/behind between our dev and upstream dev
          COUNTS=$(git rev-list --left-right --count refs/remotes/origin/development...refs/remotes/upstream/development)
          AHEAD=$(echo "$COUNTS" | awk '{print $1}')
          BEHIND=$(echo "$COUNTS" | awk '{print $2}')

          echo "DEV_AHEAD=$AHEAD"   >> $GITHUB_ENV
          echo "DEV_BEHIND=$BEHIND" >> $GITHUB_ENV

          if [ "$BEHIND" -eq 0 ]; then
            echo "DEV_STATUS_TEXT=Synced" >> $GITHUB_ENV
            echo "DEV_STATUS_BADGE=https://img.shields.io/badge/Microbot%20Dev-Synced-brightgreen?style=flat" >> $GITHUB_ENV
          else
            echo "DEV_STATUS_TEXT=Nightly Available" >> $GITHUB_ENV
            echo "DEV_STATUS_BADGE=https://img.shields.io/badge/Microbot%20Dev-Nightly%20Available-yellow?style=flat" >> $GITHUB_ENV
          fi


      # --- Microbot (development): parse nightly JAR asset version (e.g., microbot-1.9.8.1.jar) ---
      - name: Get Microbot nightly dev version from nightly assets
        id: microbot_nightly_version
        run: |
          set -e
          # Try to fetch the nightly release by its tag name
          if eval curl -fsSL $GH_HEADERS "$GH_API/repos/$UPSTREAM/releases/tags/nightly" > /tmp/microbot_nightly.json; then
            # Extract version from assets like microbot-1.9.8(.1).jar (supports 3+ parts)
            DEV_VER=$(jq -r '.assets[]?.name' /tmp/microbot_nightly.json \
              | grep -Eo '[0-9]+(\.[0-9]+){2,}' \
              | sort -V | tail -n1 || true)
          else
            DEV_VER=""
          fi

          # Fallback: if no assets matched, leave blank dash
          if [ -z "$DEV_VER" ] || [ "$DEV_VER" = "null" ]; then
            DEV_VER="—"
          fi

          echo "MICROBOT_DEV_VERSION=$DEV_VER" >> $GITHUB_ENV

      # --- RuinElite (this repo): latest numeric-looking tag, ignore 'nightly' ---
      - name: Get latest tag/release from THIS repo (RuinElite) – ignore 'nightly'
        id: ruinelite_tag
        run: |
          set -e
          OWNER_REPO="${{ github.repository }}"

          # Prefer releases, skip 'nightly', keep tags that start with >=3 numeric segments (optionally followed by -/_/+ and more)
          RUIN_REL=$(
            eval curl -fsSL $GH_HEADERS "$GH_API/repos/$OWNER_REPO/releases?per_page=100" \
            | jq -r '[.[] | .tag_name
                       | select(. != "nightly")
                       | select(test("^[0-9]+(\\.[0-9]+){2,}([_\\-\\+].*)?$"))
                     ] | .[0]'
          )

          # Fallback to tags if no releases found
          if [ -z "$RUIN_REL" ] || [ "$RUIN_REL" = "null" ]; then
            RUIN_REL=$(
              eval curl -fsSL $GH_HEADERS "$GH_API/repos/$OWNER_REPO/tags?per_page=100" \
              | jq -r '[.[] | .name
                         | select(. != "nightly")
                         | select(test("^[0-9]+(\\.[0-9]+){2,}([_\\-\\+].*)?$"))
                       ] | .[0]'
            )
          fi

          echo "RUINELITE_TAG=$RUIN_REL" >> $GITHUB_ENV

          # Split combined tag robustly:
          # Left = first >=3-segment numeric (Microbot base), Right = next numeric (your RuinElite version)
          LEFT_NUM=$(echo "$RUIN_REL" | grep -Eo '[0-9]+(\.[0-9]+){2,}' | head -n1 || true)
          RIGHT_RAW=$(echo "$RUIN_REL" | sed -E 's/^[0-9]+(\.[0-9]+){2,}[_\-\+]?//')
          RIGHT_NUM=$(echo "$RIGHT_RAW" | grep -Eo '[0-9]+(\.[0-9]+){1,}' | head -n1 || true)

          if [ -n "$RIGHT_NUM" ]; then
            MICROBOT_PART="$LEFT_NUM"
            RUINELITE_PART="$RIGHT_NUM"
          else
            MICROBOT_PART=""
            RUINELITE_PART="$LEFT_NUM"
          fi

          echo "MICROBOT_PART=$MICROBOT_PART" >> $GITHUB_ENV
          echo "RUINELITE_PART=$RUINELITE_PART" >> $GITHUB_ENV

      # --- Decide status & build table + badges ---
      - name: Decide status (Upstream Release vs Our Base) & build blocks
        id: decide
        run: |
          set -e
          MICROBOT_RELEASE="$MICROBOT_VERSION"          # upstream latest released numeric version
          RUINELITE_VERSION="$RUINELITE_PART"           # your right-side version (e.g. 1.0.0)
          OUR_BASE="${MICROBOT_PART}"                   # your release's base Microbot version (left of your combined tag)
          DEV_VER="${MICROBOT_DEV_VERSION}"

          # Upstream (release) status: Synced / New Release Available
          UPSTREAM_STATUS_TEXT="Synced"
          UPSTREAM_STATUS_BADGE="https://img.shields.io/badge/Microbot-Synced-brightgreen?style=flat"
          if [ -n "$OUR_BASE" ] && [ "$OUR_BASE" != "$MICROBOT_RELEASE" ]; then
            UPSTREAM_STATUS_TEXT="New Release Available"
            UPSTREAM_STATUS_BADGE="https://img.shields.io/badge/Microbot-New%20Release%20Available-red?style=flat"
          fi

          # Combined badge uses your combined tag (never 'nightly')
          if echo "${RUINELITE_TAG}" | grep -q "_"; then
            COMBINED="${RUINELITE_TAG}"
          else
            if [ -n "$OUR_BASE" ]; then
              COMBINED="${OUR_BASE}_${RUINELITE_VERSION}"
            else
              COMBINED="${MICROBOT_RELEASE}_${RUINELITE_VERSION}"
            fi
          fi
          COMBINED_BADGE_URL="https://img.shields.io/badge/RuinElite-${COMBINED}-blue?style=flat"

          # Build the table text — with two Microbot rows: release + dev (dev shows parsed nightly JAR version)
          printf '%s\n' \
            '| Component | Version | Status |' \
            '|---|---|---|' \
            "| **RuinElite** | \`${RUINELITE_VERSION}\` | ![Build](https://img.shields.io/github/actions/workflow/status/${{ github.repository }}/CI.yml?branch=main&label=Build&style=flat) |" \
            "| **Microbot** (*upstream*) | \`${MICROBOT_RELEASE}\` | ![Upstream](${UPSTREAM_STATUS_BADGE}) |" \
            "| **Microbot** (*development*) | \`${DEV_VER}\` | ![Dev](${{ env.DEV_STATUS_BADGE }}) |" \
            > /tmp/version_sync_block.md

          # Single-line combined badge
          echo "![RuinElite Release](${COMBINED_BADGE_URL})" > /tmp/version_badge_block.md

          echo "STATUS_TEXT=$UPSTREAM_STATUS_TEXT" >> $GITHUB_ENV

      - name: Inject table into README between SYNC markers
        run: |
          set -e
          START="<!-- SYNC:START -->"
          END="<!-- SYNC:END -->"
          awk -v start="$START" -v end="$END" -v file="/tmp/version_sync_block.md" '
            $0 ~ start {print; system("cat " file); skip=1; next}
            $0 ~ end   {print; skip=0; next}
            skip!=1 {print}
          ' README.md > README.new && mv README.new README.md

      - name: Inject badge into README between BADGE markers
        run: |
          set -e
          START="<!-- BADGE:START -->"
          END="<!-- BADGE:END -->"
          awk -v start="$START" -v end="$END" -v file="/tmp/version_badge_block.md" '
            $0 ~ start {print; system("cat " file); skip=1; next}
            $0 ~ end   {print; skip=0; next}
            skip!=1 {print}
          ' README.md > README.new && mv README.new README.md

      - name: Commit changes
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if ! git diff --quiet; then
            git add README.md
            git commit -m "chore: update Version Sync (Microbot: ${{ env.MICROBOT_VERSION }} | Dev: ${{ env.DEV_STATUS_TEXT }} | DevVer: ${{ env.MICROBOT_DEV_VERSION }})"
            git push
          fi
